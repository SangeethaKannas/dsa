# Graph Algorithms
1. Breadth-first search: Traverses a graph level by level, exploring all neighbors of a node before moving on to the next level.

2. Depth-first search: Explores as far as possible along each branch before backtracking, often implemented using recursion.

3. Shortest path: Finds the most efficient path between two nodes in terms of the sum of edge weights.

4. Cycle detection: Identifies the presence of cycles (loops) in a graph, crucial for detecting dependencies and avoiding infinite loops.

5. Minimum spanning tree: Finds the subset of edges that connects all vertices with the minimum total edge weight, forming a tree.

6. Strongly connected components: Divides a directed graph into strongly connected subgraphs, where each vertex is reachable from every other vertex.

7. Topological sorting: Orders the vertices of a directed acyclic graph in such a way that for every directed edge, the destination vertex comes after the source vertex.

8. Graph Colouring: Assigns colors to vertices of a graph such that no two adjacent vertices share the same color, often used in scheduling and resource allocation.

9. Maximum flow: Determines the maximum amount of flow that can be sent from a designated source to a designated sink in a flow network.

10. Matching: Identifies edges in a graph such that no two edges share a common vertex, often used in bipartite graph matching or assignment problems.